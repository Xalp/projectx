module gamefsm (
    input clk,  // clock
    input rst, // reset
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],     // Digit select on IO Shield
  
    input b1_press,
    input b2_press,
    input b3_press,    
    output io_led[3]
    //output b1_light,
    //output b2_light,
    //output b3_light    
    ) {

  sig a[3];
  sig b[3];
//  sig alufn[6];    
//  sig alu[16];
//  alu alumod; 
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    fsm state = {IDLE, CASE1, CASE2 };
    
    //there's no point creating a separate memory unit luc source file since it is very small, and no logic for retrieving data. 
    dff store_b1_press[16];      //delay flip flops used for storing values of a,b,store_alufn
    dff store_b2_press[16];
    dff store_b3_press[16];
    dff store_test_cases[16];
    .rst(rst){
  
     //  dff store_a[3];   // a is test case input, to retrieve from memory unit
     // dff store_b[3];   //b is user input 
     // dff store_alufn[6]; //do i even need to store alufn into mem unit? i think not
      stateCounter stateCOUNT;
      multi_seven_seg seg;  //using module multi_seven_seg

    }
  }
  sig user_input[16];
  always {
    io_seg = ~seg.seg;
    io_sel = ~seg.sel;
    seg.values = {4h0,4h0}; //initial score
    
    a=0; //test case 0 at start
    
    //a is supplied in each test case, b is user inputs from b1_press, b2_press, b3_press, etc from au_top
    b[2] = b1_press;
    b[1] = b2_press;
    b[0] = b3_press;
    io_led=0;
    store_b1_press.d = b1_press;
    store_b2_press.d = b2_press;
    store_b3_press.d = b3_press;
    store_test_cases.d =  1110101011010111;// 111 010 011 101 110 001 5 shifts 5 test cases
    
    user_input[15:3] = 0; //last 13 bits of user input always 0
//    alufn=0;
//    alumod.alufn = alufn;
//    alumod.a = a;          //put the test case into the alu input a      
//    alumod.b = b;          //put user inputs into alu input b  
      case (state.q){                 //initial start state of finite state machine
    state.IDLE:
        seg.values = {4h9, 4h9};
        //if middle button is pressed, game starts, go to first test case
        if(b2_press) {
          seg.values={4h0,4h0};
          state.d = state.CASE1;
          }
        else{
          io_led = 0;
        }
    state.CASE1:                   
        if(stateCOUNT.inc_state==1 || (store_b1_press.q == 1 && store_b2_press.q == 1 && store_b3_press.q == 1)) {
          seg.values={4h0,4h1};
          state.d = state.CASE2;        
          }
    state.CASE2:
        seg.values={4h0,4h2};
        /*
        // more state logic to check if input presses b matches test cases a
        if(){ 
        } */        
        
     } //encapsulates case(state.q)
  }
